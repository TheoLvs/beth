{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u265f Welcome to beth documentation \u00b6 beth is an open source chess AI framework. Like many, I re-discovered the game of chess by watching the Netflix show the Queen's Gambit . As a Data Scientist, it made we want to learn and explore the beauty of the game. At first my goal was to develop algorithms to help me learn chess. But over time, it lead to developing more and more features. What you will find is my personal experiments open sourced as a chess framework. I hope this framework to be ideal for chess programmers in Python to ease the development of new algorithms and engines. Warning This repo is under active development, many features are still experimental. But please fill free to fork or PR Installation \u00b6 You can install the library from PyPi with: pip install beth Or clone and install from source Features \u00b6 Definition of a game environment using python-chess framework, with move parsing, board-to-numpy abstractions, PGN records, move replay. Playing chess in Jupyter notebooks with widgets Different player abstractions: HumanPlayer() , RandomPlayer() , AIPlayer() - to play Human vs AI, Human vs Human, or AI vs AI. Connection to Stockfis engine to evaluate engine performances, available with StockfishAI() object abstraction Rules-based engine TreeSearchAI() with minimax tree search, alpha beta pruning, move ordering and board heuristics (~ELO 1000) First attempt of ML engine with a LSTM Neural Network to predict next moves Next roadmap features \u00b6 If you are interested, please drop an issue or a PR, or contact me by email . Meanwhile the roadmap for beth is: Implementing a GUI (or connecting to an existing one) to ease experimentation ELO or TrueSkill measurement for any engine Improving minimax engine speed Developing ML engines: Self supervised learning with Transformers Reinforcement Learning Repo Structure \u00b6 - beth/ - data/ - raw/ - processed/ - docs/ # Documentation folder and website (.md, .ipynb) using Mkdocs - notebooks/ # Jupyter notebooks only (.ipynb) - tests/ # Unitary testing using pytest - .gitignore - LICENSE # MIT License - poetry.lock # Poetry lock file - pyproject.toml # Configuration file to export and package the library using Poetry","title":"Welcome"},{"location":"#welcome-to-beth-documentation","text":"beth is an open source chess AI framework. Like many, I re-discovered the game of chess by watching the Netflix show the Queen's Gambit . As a Data Scientist, it made we want to learn and explore the beauty of the game. At first my goal was to develop algorithms to help me learn chess. But over time, it lead to developing more and more features. What you will find is my personal experiments open sourced as a chess framework. I hope this framework to be ideal for chess programmers in Python to ease the development of new algorithms and engines. Warning This repo is under active development, many features are still experimental. But please fill free to fork or PR","title":"\u265f Welcome to beth documentation"},{"location":"#installation","text":"You can install the library from PyPi with: pip install beth Or clone and install from source","title":"Installation"},{"location":"#features","text":"Definition of a game environment using python-chess framework, with move parsing, board-to-numpy abstractions, PGN records, move replay. Playing chess in Jupyter notebooks with widgets Different player abstractions: HumanPlayer() , RandomPlayer() , AIPlayer() - to play Human vs AI, Human vs Human, or AI vs AI. Connection to Stockfis engine to evaluate engine performances, available with StockfishAI() object abstraction Rules-based engine TreeSearchAI() with minimax tree search, alpha beta pruning, move ordering and board heuristics (~ELO 1000) First attempt of ML engine with a LSTM Neural Network to predict next moves","title":"Features"},{"location":"#next-roadmap-features","text":"If you are interested, please drop an issue or a PR, or contact me by email . Meanwhile the roadmap for beth is: Implementing a GUI (or connecting to an existing one) to ease experimentation ELO or TrueSkill measurement for any engine Improving minimax engine speed Developing ML engines: Self supervised learning with Transformers Reinforcement Learning","title":"Next roadmap features"},{"location":"#repo-structure","text":"- beth/ - data/ - raw/ - processed/ - docs/ # Documentation folder and website (.md, .ipynb) using Mkdocs - notebooks/ # Jupyter notebooks only (.ipynb) - tests/ # Unitary testing using pytest - .gitignore - LICENSE # MIT License - poetry.lock # Poetry lock file - pyproject.toml # Configuration file to export and package the library using Poetry","title":"Repo Structure"},{"location":"home/common-questions/","text":"Common questions \u00b6 Warning Under construction","title":"Common questions"},{"location":"home/common-questions/#common-questions","text":"Warning Under construction","title":"Common questions"},{"location":"home/installation/","text":"Installation \u00b6 Install from PyPi \u00b6 The simplest way to install the library is from PyPi: pip install beth More information at https://pypi.org/project/beth/","title":"Installation"},{"location":"home/installation/#installation","text":"","title":"Installation"},{"location":"home/installation/#install-from-pypi","text":"The simplest way to install the library is from PyPi: pip install beth More information at https://pypi.org/project/beth/","title":"Install from PyPi"},{"location":"home/quickstart/","text":"Quickstart \u00b6 Playing a game of chess in a Jupyter notebook \u00b6 2 Human Players (or yourself) playing a game \u00b6 from beth.game import Game from beth.players.random_player import RandomPlayer from beth.players.human_player import HumanPlayer # Instantiate player and game white = HumanPlayer () black = HumanPlayer () game = Game ( white , black ) # Run the game to play in the notebook game . run () Playing from a game checkpoint (after a list of moves) \u00b6 game = Game ( white , black ) scores = game . move ([ \"e4\" , \"d5\" , \"d5\" , \"g8f6\" , \"d4\" , \"f6d5\" ]) The engine use python-chess to display the board as SVG and parse SAN (standard algebric notation) moves. It also returns the scores , ie the points for each move, with the standard conventions (and positive for white and negative for black captures) 1 for a pawn captured 3 for a bishop or a knight 5 for a rook 9 for a queen 200 for a king checkmated In the example above, scores >>> [ 0 , 0 , 1 , 0 , 0 , - 1 ] Playing against a chess engine \u00b6 Warning Under construction","title":"Quickstart"},{"location":"home/quickstart/#quickstart","text":"","title":"Quickstart"},{"location":"home/quickstart/#playing-a-game-of-chess-in-a-jupyter-notebook","text":"","title":"Playing a game of chess in a Jupyter notebook"},{"location":"home/quickstart/#2-human-players-or-yourself-playing-a-game","text":"from beth.game import Game from beth.players.random_player import RandomPlayer from beth.players.human_player import HumanPlayer # Instantiate player and game white = HumanPlayer () black = HumanPlayer () game = Game ( white , black ) # Run the game to play in the notebook game . run ()","title":"2 Human Players (or yourself) playing a game"},{"location":"home/quickstart/#playing-from-a-game-checkpoint-after-a-list-of-moves","text":"game = Game ( white , black ) scores = game . move ([ \"e4\" , \"d5\" , \"d5\" , \"g8f6\" , \"d4\" , \"f6d5\" ]) The engine use python-chess to display the board as SVG and parse SAN (standard algebric notation) moves. It also returns the scores , ie the points for each move, with the standard conventions (and positive for white and negative for black captures) 1 for a pawn captured 3 for a bishop or a knight 5 for a rook 9 for a queen 200 for a king checkmated In the example above, scores >>> [ 0 , 0 , 1 , 0 , 0 , - 1 ]","title":"Playing from a game checkpoint (after a list of moves)"},{"location":"home/quickstart/#playing-against-a-chess-engine","text":"Warning Under construction","title":"Playing against a chess engine"},{"location":"home/releases/","text":"Changelog \u00b6 Find here the latest libray release and information Note Feel free to explore the PyPi release tree https://pypi.org/project/beth/ v0.2.0 (2021-03-13) \u00b6 Added documentation with mkdocs First tests with pytest Stockfish engine connection with StockfishAI() abstraction Minimax engine development with alpha-beta pruning, move ordering, timeout, and board heuristics Board parsing to numpy 4D tensors PGN saving features v0.1.0 (2021-02-13) \u00b6 Structure of the library (Game, Players, Board) Move parsing and capture heuristics Visualization and games logic in jupyter notebooks RandomPlayer baseline who play random moves for testing Experimenting with LSTM predictions","title":"Changelog"},{"location":"home/releases/#changelog","text":"Find here the latest libray release and information Note Feel free to explore the PyPi release tree https://pypi.org/project/beth/","title":"Changelog"},{"location":"home/releases/#v020-2021-03-13","text":"Added documentation with mkdocs First tests with pytest Stockfish engine connection with StockfishAI() abstraction Minimax engine development with alpha-beta pruning, move ordering, timeout, and board heuristics Board parsing to numpy 4D tensors PGN saving features","title":"v0.2.0 (2021-03-13)"},{"location":"home/releases/#v010-2021-02-13","text":"Structure of the library (Game, Players, Board) Move parsing and capture heuristics Visualization and games logic in jupyter notebooks RandomPlayer baseline who play random moves for testing Experimenting with LSTM predictions","title":"v0.1.0 (2021-02-13)"},{"location":"library/","text":"API documentation \u00b6 Find in this section all API information of the libary Library structure \u00b6 ai # The different AI engines evaluation # To evaluate the ELO or TrueSkill level models # ML models utils players # Player abstractions tree # Search tree abstractions board.py # Board representation constants.py # All constants used across the libraries (piece names, values, etc...) game.py # Game representation (main class of the library) heuristics.py # Board heuristics constants and helper functions move.py # Move parsing abstraction piece.py # Piece helper functions utils.py # Other helper functions","title":"Home"},{"location":"library/#api-documentation","text":"Find in this section all API information of the libary","title":"API documentation"},{"location":"library/#library-structure","text":"ai # The different AI engines evaluation # To evaluate the ELO or TrueSkill level models # ML models utils players # Player abstractions tree # Search tree abstractions board.py # Board representation constants.py # All constants used across the libraries (piece names, values, etc...) game.py # Game representation (main class of the library) heuristics.py # Board heuristics constants and helper functions move.py # Move parsing abstraction piece.py # Piece helper functions utils.py # Other helper functions","title":"Library structure"},{"location":"library/core/board/","text":"\u00b6 Board \u00b6 deepcopy ( self ) \u00b6 Duplicate the board with the current pieces positions Will be used for board evaluation and traversing tree search engines Returns: Type Description Board the same duplicated board as the current object Source code in beth\\board.py def deepcopy ( self ): \"\"\"Duplicate the board with the current pieces positions Will be used for board evaluation and traversing tree search engines Returns: Board: the same duplicated board as the current object \"\"\" return deepcopy ( self ) get_pieces_positions_by_type ( self , piece_type , color = None ) \u00b6 Parse the bitboard representation to get pieces positions on the board Parameters: Name Type Description Default piece_type str the name of the piece in uppercase required color str WHITE or BLACK. Defaults to None. None Exceptions: Type Description Exception if the name of the piece is not recognized (practical to debug) Returns: Type Description list list: The position (between 0 and 63) of the piece type selected Source code in beth\\board.py def get_pieces_positions_by_type ( self , piece_type : str , color : str = None ) -> list : \"\"\"Parse the bitboard representation to get pieces positions on the board Args: piece_type (str): the name of the piece in uppercase color (str, optional): WHITE or BLACK. Defaults to None. Raises: Exception: if the name of the piece is not recognized (practical to debug) Returns: list: The position (between 0 and 63) of the piece type selected \"\"\" # Prepare binary representation of pieces piece_type = piece_type . upper () if piece_type == \"BISHOP\" : pieces = self . bishops elif piece_type == \"PAWN\" : pieces = self . pawns elif piece_type == \"ROOK\" : pieces = self . rooks elif piece_type == \"KNIGHT\" : pieces = self . knights elif piece_type == \"QUEEN\" : pieces = self . queens elif piece_type == \"KING\" : pieces = self . kings else : raise Exception ( f \"Piece type { piece_type } is not among { PIECES } \" ) # Prepare binary color mask if color is None : mask = self . occupied else : if isinstance ( color , str ): color = 0 if color . upper () == \"WHITE\" else 1 mask = self . occupied_co [ 1 - color ] return list ( scan_forward ( pieces & mask ))","title":"Board"},{"location":"library/core/board/#beth.board","text":"","title":"beth.board"},{"location":"library/core/board/#beth.board.Board","text":"","title":"Board"},{"location":"library/core/board/#beth.board.Board.deepcopy","text":"Duplicate the board with the current pieces positions Will be used for board evaluation and traversing tree search engines Returns: Type Description Board the same duplicated board as the current object Source code in beth\\board.py def deepcopy ( self ): \"\"\"Duplicate the board with the current pieces positions Will be used for board evaluation and traversing tree search engines Returns: Board: the same duplicated board as the current object \"\"\" return deepcopy ( self )","title":"deepcopy()"},{"location":"library/core/board/#beth.board.Board.get_pieces_positions_by_type","text":"Parse the bitboard representation to get pieces positions on the board Parameters: Name Type Description Default piece_type str the name of the piece in uppercase required color str WHITE or BLACK. Defaults to None. None Exceptions: Type Description Exception if the name of the piece is not recognized (practical to debug) Returns: Type Description list list: The position (between 0 and 63) of the piece type selected Source code in beth\\board.py def get_pieces_positions_by_type ( self , piece_type : str , color : str = None ) -> list : \"\"\"Parse the bitboard representation to get pieces positions on the board Args: piece_type (str): the name of the piece in uppercase color (str, optional): WHITE or BLACK. Defaults to None. Raises: Exception: if the name of the piece is not recognized (practical to debug) Returns: list: The position (between 0 and 63) of the piece type selected \"\"\" # Prepare binary representation of pieces piece_type = piece_type . upper () if piece_type == \"BISHOP\" : pieces = self . bishops elif piece_type == \"PAWN\" : pieces = self . pawns elif piece_type == \"ROOK\" : pieces = self . rooks elif piece_type == \"KNIGHT\" : pieces = self . knights elif piece_type == \"QUEEN\" : pieces = self . queens elif piece_type == \"KING\" : pieces = self . kings else : raise Exception ( f \"Piece type { piece_type } is not among { PIECES } \" ) # Prepare binary color mask if color is None : mask = self . occupied else : if isinstance ( color , str ): color = 0 if color . upper () == \"WHITE\" else 1 mask = self . occupied_co [ 1 - color ] return list ( scan_forward ( pieces & mask ))","title":"get_pieces_positions_by_type()"},{"location":"library/core/constants/","text":"","title":"Constants"},{"location":"library/core/game/","text":"\u00b6 Game \u00b6 done ( self ) \u00b6 Indicator if the game is finished Used to end game loops Can be included: - board.is_stalemate() - board.is_insufficient_material() - board.is_game_over() Returns: Type Description bool If the game is finished Source code in beth\\game.py def done ( self ): \"\"\"Indicator if the game is finished Used to end game loops Can be included: - board.is_stalemate() - board.is_insufficient_material() - board.is_game_over() Returns: bool: If the game is finished \"\"\" if self . board . is_checkmate (): return True elif self . board . is_stalemate (): return True elif self . board . is_fivefold_repetition (): return True elif self . board . is_seventyfive_moves (): return True elif self . board . is_insufficient_material (): return True else : return False","title":"Game"},{"location":"library/core/game/#beth.game","text":"","title":"beth.game"},{"location":"library/core/game/#beth.game.Game","text":"","title":"Game"},{"location":"library/core/game/#beth.game.Game.done","text":"Indicator if the game is finished Used to end game loops Can be included: - board.is_stalemate() - board.is_insufficient_material() - board.is_game_over() Returns: Type Description bool If the game is finished Source code in beth\\game.py def done ( self ): \"\"\"Indicator if the game is finished Used to end game loops Can be included: - board.is_stalemate() - board.is_insufficient_material() - board.is_game_over() Returns: bool: If the game is finished \"\"\" if self . board . is_checkmate (): return True elif self . board . is_stalemate (): return True elif self . board . is_fivefold_repetition (): return True elif self . board . is_seventyfive_moves (): return True elif self . board . is_insufficient_material (): return True else : return False","title":"done()"},{"location":"tutorials/notebook-test/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); # Base Data Science snippet import pandas as pd import numpy as np import matplotlib.pyplot as plt import os import time from tqdm import tqdm_notebook % matplotlib inline % load_ext autoreload % autoreload 2 print ( \"hello\" ) hello plt . plot ([ 1 , 2 , 3 ]) [<matplotlib.lines.Line2D at 0x1a660391c88>]","title":"Notebook test"},{"location":"tutorials/quickstart/","text":"","title":"Quickstart"}]}